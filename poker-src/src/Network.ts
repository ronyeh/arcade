import SimplePeer, { Instance as PeerInstance, SignalData } from 'simple-peer';

export interface GameMessage {
  type: string; // e.g., 'gameState', 'playerAction', 'dealCards', 'chat'
  payload: any; // Content of the message
  senderId?: string; // Optional: to identify who sent it if multiple peers later
}

export class Network {
  peer?: PeerInstance;
  private onDataReceivedCallback: (message: GameMessage) => void;
  private onConnectCallback?: () => void;
  private onSignalCallback: (signal: SignalData) => void;
  private onCloseCallback?: () => void;
  private onErrorCallback?: (error: Error) => void;

  constructor(
    onDataReceived: (message: GameMessage) => void,
    onSignal: (signal: SignalData) => void,
    onConnect?: () => void,
    onClose?: () => void,
    onError?: (error: Error) => void,
  ) {
    this.onDataReceivedCallback = onDataReceived;
    this.onSignalCallback = onSignal;
    this.onConnectCallback = onConnect;
    this.onCloseCallback = onClose;
    this.onErrorCallback = onError;
    console.log("Network class instantiated.");
  }

  private setupPeerHandlers(p: PeerInstance): void {
    p.on('signal', (data) => {
      console.log('SIGNAL data generated by peer:', data);
      this.onSignalCallback(data); // Pass signal to UI/main to display
    });

    p.on('connect', () => {
      console.log('PEER CONNECTED');
      if (this.onConnectCallback) {
        this.onConnectCallback();
      }
      // Could send a default "hello" message
      // this.send({ type: 'info', payload: 'Connection established!' });
    });

    p.on('data', (data) => {
      console.log('DATA received from peer:', data.toString());
      try {
        const message = JSON.parse(data.toString()) as GameMessage;
        this.onDataReceivedCallback(message);
      } catch (error) {
        console.error('Error parsing received data:', error);
        if (this.onErrorCallback) {
            this.onErrorCallback(new Error("Error parsing received data"));
        }
      }
    });

    p.on('error', (err) => {
      console.error('PEER ERROR:', err);
      if (this.onErrorCallback) {
        this.onErrorCallback(err instanceof Error ? err : new Error(String(err)) );
      }
    });

    p.on('close', () => {
      console.log('PEER CONNECTION CLOSED');
      if (this.onCloseCallback) {
        this.onCloseCallback();
      }
      this.peer = undefined; // Clear the peer instance on close
    });
  }

  public initiateConnection(): void {
    if (this.peer) {
      console.warn("Peer already exists. Destroying old one.");
      this.peer.destroy();
    }
    console.log("Initiating peer connection...");
    this.peer = new SimplePeer({
      initiator: true,
      trickle: false, // Simplifies manual signaling by sending one big signal blob
    });
    this.setupPeerHandlers(this.peer);
  }

  public connectToPeerSignal(signalData: SignalData | string): void {
    if (this.peer && this.peer.initiator) {
        // This is the initiator receiving an answer signal
        console.log("Initiator received answer signal. Applying signal...");
        try {
            const parsedSignal = typeof signalData === 'string' ? JSON.parse(signalData) : signalData;
            this.peer.signal(parsedSignal);
        } catch (e) {
            console.error("Error parsing or applying signal data:", e);
             if (this.onErrorCallback) {
                this.onErrorCallback(e instanceof Error ? e : new Error("Failed to parse signal data"));
            }
        }
        return;
    }

    // This is the joiner creating a peer and applying the offer signal
    if (this.peer) {
      console.warn("Peer already exists (as joiner). Destroying old one.");
      this.peer.destroy();
    }
    console.log("Joining peer with received offer signal...");
    this.peer = new SimplePeer({
      initiator: false,
      trickle: false,
    });
    this.setupPeerHandlers(this.peer);
    try {
        const parsedSignal = typeof signalData === 'string' ? JSON.parse(signalData) : signalData;
        this.peer.signal(parsedSignal); // Apply the offer signal from the initiator
    } catch (e) {
        console.error("Error parsing or applying signal data:", e);
        if (this.onErrorCallback) {
            this.onErrorCallback(e instanceof Error ? e : new Error("Failed to parse signal data"));
        }
    }
  }

  public get isConnected(): boolean {
    return this.peer ? this.peer.connected : false;
  }

  public send(message: GameMessage): boolean {
    if (this.peer && this.peer.connected) {
      try {
        const messageString = JSON.stringify(message);
        this.peer.send(messageString);
        console.log('Sent message:', message);
        return true;
      } catch (error) {
        console.error('Error sending message:', error);
        if (this.onErrorCallback) {
            this.onErrorCallback(new Error("Error stringifying or sending message"));
        }
        return false;
      }
    } else {
      console.warn('Cannot send message, peer not connected.');
      return false;
    }
  }

  public disconnect(): void {
    if (this.peer) {
      console.log("Disconnecting peer...");
      this.peer.destroy();
      this.peer = undefined;
    }
  }
}
